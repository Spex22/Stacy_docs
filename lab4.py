# класс объектов-итераторов
# для указания текущего элемента
# в последовательности

class RangeIterator:
    # при создании создает переменные
    # для хранения текущего состояния
    def __init__(self, size):
        self.x4 = 0
        self.x1 = 0
        self.x2 = 0
        self.x3 = 1
        self.x = 0
        self.size = size

    # единственное, что можно делать с итератором -
    # двигать его на следующий элемент последовательности
    # это то, что делает итератор итератором
    def __next__(self):
        self.x += 1
        if self.x == 1:
            return self.x1
        if self.x == 2:
            return self.x2
        if self.x == 3:
            return self.x3
        # возвращает элементы последовательности трибоначчи
        # если последовательность итератора
        # не бесконечна - должно быть условие
        # для окончания цикла
        if self.x > self.size:
            # для окончания цикла в итераторе
            # вызывается специальное исключение StopIteration
            raise StopIteration
        self.x4 = (self.x1 + self.x2 + self.x3)
        self.x1 = self.x2
        self.x2 = self.x3
        self.x3 = self.x4
        return self.x4

# класс итерируемых объектов
class RangeIterable:
    def __init__(self, size):
        self.size = size

    # для прохода по итерируемому объекту с помощью цикла
    # в начале цикла вызывается метод __iter__
    # для получения итератора
    # это то, что делает объект итерируемым
    def __iter__(self):
        return RangeIterator(self.size)


# главная программа с заголовком,
# позволяющим использовать этот файл как модуль:
if __name__ == '__main__':
    # создание итерируемого объекта
    main_iter = RangeIterable(35)
    # проход по итерируемому объекту с помощью цикла
    for x in main_iter:
        # вывод текущего элемента (который возвращает итератор)
        print(x)